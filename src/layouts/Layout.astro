---
import Footer from "../components/Footer.astro";
import Header from "../components/Header.astro";
import "../styles/global.css";
import { ClientRouter } from "astro:transitions";
---

<!doctype html>
<html lang="en">
  <head>
    <ClientRouter />

    <script>
      // Runs before CSS, prevents FOUC
      (function () {
        const theme = localStorage.getItem("theme");
        if (
          theme === "dark" ||
          (!theme && window.matchMedia("(prefers-color-scheme: dark)").matches)
        ) {
          document.documentElement.classList.add("dark");
        }
      })();
    </script>

    <script is:inline>
      function applyTheme() {
        const theme = localStorage.getItem("theme") || "dark";
        document.documentElement.classList.toggle("dark", theme === "dark");
      }

      function toggleTheme() {
        const isDark = document.documentElement.classList.toggle("dark");
        localStorage.setItem("theme", isDark ? "dark" : "light");
      }

      function bindToggle() {
        const btn = document.getElementById("themeToggle");
        if (btn && !btn.dataset.bound) {
          btn.addEventListener("click", toggleTheme);
          btn.dataset.bound = "true";
        }
      }

      // On full load
      applyTheme();
      bindToggle();

      // On ClientRouter transitions
      document.addEventListener("astro:page-load", () => {
        applyTheme();
        bindToggle();
      });
      document.addEventListener("astro:after-swap", () => {
        applyTheme(); // üîÅ re-apply theme every time
        bindToggle();
      });
    </script>

    <script>
      // =============================================================================
      //  CONSOLIDATED SPECIAL EFFECTS SCRIPT
      // =============================================================================

      // --- 1. Text Scramble Effect Class ---
      class TextScramble {
        constructor(el) {
          this.el = el;
          this.chars = "!<>-_\\/[]{}‚Äî=+*^?#________";
          this.update = this.update.bind(this);
        }

        setText(newText) {
          // Find and store the SVG before starting
          this.svg = this.el.querySelector("svg");
          if (this.svg) {
            this.svg.remove();
          }

          // --- ADDED: Freeze the element's size before animating ---
          const { width, height } = this.el.getBoundingClientRect();
          this.el.style.width = `${width}px`;
          this.el.style.height = `${height}px`;

          const oldText = this.el.innerText;
          const length = Math.max(oldText.length, newText.length);
          const promise = new Promise((resolve) => (this.resolve = resolve));

          this.queue = [];
          for (let i = 0; i < length; i++) {
            const from = oldText[i] || "";
            const to = newText[i] || "";
            const start = Math.floor(Math.random() * 40);
            const end = start + Math.floor(Math.random() * 40);
            this.queue.push({ from, to, start, end });
          }

          cancelAnimationFrame(this.frameRequest);
          this.frame = 0;
          this.update();
          return promise;
        }

        update() {
          let output = "";
          let complete = 0;
          for (let i = 0, n = this.queue.length; i < n; i++) {
            let { from, to, start, end, char } = this.queue[i];
            if (this.frame >= end) {
              complete++;
              output += to;
            } else if (this.frame >= start) {
              if (!char || Math.random() < 0.28) {
                char = this.randomChar();
                this.queue[i].char = char;
              }
              output += `<span class="scramble-char">${char}</span>`;
            } else {
              output += from;
            }
          }

          this.el.innerHTML = output;

          if (complete === this.queue.length) {
            if (this.svg) {
              this.el.appendChild(this.svg);
            }
            this.resolve();
          } else {
            this.frameRequest = requestAnimationFrame(this.update);
            this.frame++;
          }
        }

        randomChar() {
          return this.chars[Math.floor(Math.random() * this.chars.length)];
        }
      }

      // --- 2. Master Effects Initializer ---
      function initializePageEffects() {
        document.querySelectorAll(".has-text-scramble").forEach((el) => {
          // Failsafe to prevent attaching multiple listeners to the same element
          if (el.dataset.scrambleInitialized) return;

          const fx = new TextScramble(el);
          const originalText = el.innerText;
          let isScrambling = false;

          el.addEventListener("mouseenter", () => {
            if (isScrambling) return;
            isScrambling = true;

            // REMOVED: el.style.pointerEvents = "none";

            fx.setText(originalText).then(() => {
              isScrambling = false;
              el.style.width = "";
              el.style.height = "";
              // REMOVED: el.style.pointerEvents = "";
            });
          });
          el.dataset.scrambleInitialized = "true";
        }); // --- Scroll-triggered Fade-Up Effect ---
        const scrollObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add("is-visible");
                scrollObserver.unobserve(entry.target);
              }
            });
          },
          { threshold: 0.1 },
        );
        document.querySelectorAll(".animate-on-scroll").forEach((el) => {
          scrollObserver.observe(el);
        });

        function setupRandomParallax() {
          // Select all timeline snippet components as potential candidates
          const candidates = document.querySelectorAll(".group.relative");

          candidates.forEach((el) => {
            // Failsafe: If this element has already been wrapped, skip it.
            if (el.parentElement.classList.contains("parallax-container")) {
              return;
            }

            // Randomly apply the effect to about 1 in 3 elements
            if (Math.random() < 0.33) {
              // 1. Create the parallax container
              const parallaxContainer = document.createElement("div");
              parallaxContainer.classList.add("parallax-container");

              // 2. Wrap the original snippet element with the container
              el.parentNode.insertBefore(parallaxContainer, el);
              parallaxContainer.appendChild(el);

              // 3. Add the parallax class to the snippet itself
              el.classList.add("parallax-element");

              // 4. Set a random speed for a more dynamic feel
              const randomSpeed = -(Math.random() * 0.4 + 0.1).toFixed(2);
              el.dataset.speed = randomSpeed;
            }
          });

          // --- Magnetic Nudge Effect ---

          document.querySelectorAll(".is-magnetic").forEach((magneticEl) => {
            const childEl = magneticEl.children[0];
            if (!childEl) return; // Failsafe if the element is empty

            magneticEl.addEventListener("mousemove", (e) => {
              const { clientX, clientY } = e;
              const { left, top, width, height } =
                magneticEl.getBoundingClientRect();
              const x = (clientX - left - width / 2) * 0.2; // Multiplier can be adjusted for more/less effect
              const y = (clientY - top - height / 2) * 0.2;

              // Apply transform to the CHILD, not the parent wrapper
              childEl.style.transform = `translate(${x}px, ${y}px)`;
            });

            magneticEl.addEventListener("mouseleave", () => {
              // Reset the CHILD's transform
              childEl.style.transform = "translate(0, 0)";
            });
          });

          // --- Interactive Card 3D Tilt & Spotlight Effect ---
          document.querySelectorAll(".interactive-card").forEach((card) => {
            card.addEventListener("mousemove", (e) => {
              const rect = card.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              const rotateY =
                -1 * ((x - rect.width / 2) / (rect.width / 2)) * 8; // Max 8 degrees
              const rotateX = ((y - rect.height / 2) / (rect.height / 2)) * 8; // Max 8 degrees
              card.style.setProperty("--rotate-x", `${rotateX}deg`);
              card.style.setProperty("--rotate-y", `${rotateY}deg`);
              card.style.setProperty(
                "--spotlight-x",
                `${e.clientX - rect.left}px`,
              );
              card.style.setProperty(
                "--spotlight-y",
                `${e.clientY - rect.top}px`,
              );
            });
            card.addEventListener("mouseleave", () => {
              card.style.setProperty("--rotate-x", "0deg");
              card.style.setProperty("--rotate-y", "0deg");
            });
          });

          // --- Parallax Effect ---
          const parallaxElements =
            document.querySelectorAll(".parallax-element");
          window.addEventListener("scroll", () => {
            const scrollY = window.scrollY;
            parallaxElements.forEach((el) => {
              const speed = parseFloat(el.dataset.speed) || -0.5;
              const z = scrollY * speed;
              el.style.transform = `translateZ(${z}px)`;
            });
          });

          // --- CALL THE NEW FUNCTION AT THE END ---
          setupRandomParallax();
        }
      }
      // --- 3. Event Listeners ---
      // Run on initial page load
      document.addEventListener("DOMContentLoaded", initializePageEffects);
      // Re-run after Astro's client-side navigation
      document.addEventListener("astro:after-swap", initializePageEffects);
    </script>

    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="generator" content={Astro.generator} />
    <link rel="preconnect" href="https://fonts.bunny.net" />
    <link
      href="https://fonts.bunny.net/css?family=ibm-plex-mono:400,400i,500,500i,600,600i,700,700i"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    />

    <slot name="head" />
  </head>
  <body
    class="zag-bg zag-text has-variable-font-animation zag-responsive-container w-full-vw"
  >
    <Header />

    <main>
      <slot />
    </main>
    <Footer />
  </body>
</html>
